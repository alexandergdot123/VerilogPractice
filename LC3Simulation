

module Full_Adder (input A, input B, input Cin, output sum, output Cout);
	assign sum = A^B^Cin;
	assign Cout = (A&B) | (B&Cin) | (A&Cin);
endmodule


module Sixteenbitadder (input[15:0] A, input [15:0] B, input Cin, output [15:0] Sum, output Cout);
	wire [16:0] intermediate;
	assign intermediate[0] = Cin;
	genvar i;
	generate
		for(i=0; i<16; i=i+1) begin : FullAdders
			Full_Adder instances (A[i], B[i], intermediate[i], Sum[i], intermediate[i+1]);
		end
	endgenerate
	assign Cout = intermediate[16];
endmodule

module ALU (input [1:0] control, input [15:0] A, input [15:0] B, output [15:0] out);
	wire [15:0] insertA;
	wire [15:0] insertB;
	assign insertB = ~({16{control[1]}} | {16{control[0]}}) & B;
	assign insertA = (control[0]) ? A&B : A ^ {16{control[1]}};
	Sixteenbitadder Adder (insertA, insertB, 0, out, 0);
endmodule
/*
module registerfile (input clk, input [15:0] newb, input [2:0] DR, input LDREG, input [2:0] SR2, input [2:0] SR1, output [15:0] SR2OUT, output [15:0] SR1OUT); 
	reg [127:0] RegisterTable;
	wire [6:0] DRtall;
	wire [6:0] DRshort;
	wire [6:0] SR1tall;
	wire [6:0] SR1short;
	wire [6:0] SR2tall;
	wire [6:0] SR2short;
	assign DRtall[6:4] = DR;
	assign DRtall[3:0] = 4'b1111;
	assign SR1tall[6:4] = SR1;
	assign SR1tall[3:0] = 4'b1111;
	assign SR2tall[6:4] = SR2;
	assign SR2tall[3:0] = 4'b1111;
	assign DRshort[6:4] = DR;
	assign DRshort[3:0] = 4'b0000;
	assign SR1short[6:4] = SR1;
	assign SR1short[3:0] = 4'b0000;
	assign SR2short[6:4] = SR2;
	assign SR2short[3:0] = 4'b0000;
	assign SR2OUT = RegisterTable[SR2tall:SR2short];
	assign SR1OUT = RegisterTable[SR1tall:SR1short];
	always @(posedge clk) begin
		if(LDREG) begin
			RegisterTable[DRtall:DRshort] <= newb;
		end
		else
			RegisterTable[DRtall:DRshort] <= RegisterTable[DRtall:DRshort];
	end
endmodule
*/

module RegisterFile #(
  parameter DataWidth  = 16,
  parameter NumRegs    = 8,
  parameter IndexWidth = $clog2(NumRegs)
) (
  input                    clk,
  input                    writeEn,
  input   [IndexWidth-1:0] writeAddr,
  input   [ DataWidth-1:0] writeData,
  input   [IndexWidth-1:0] readAddr1,
  input   [IndexWidth-1:0] readAddr2,
  output  [ DataWidth-1:0] readData1,
  output  [ DataWidth-1:0] readData2
);

  reg [DataWidth-1:0] regs[NumRegs];

  always @(posedge clk) begin
    if (writeEn) begin
      regs[writeAddr] <= writeData;
    end
  end

  assign readData1 = regs[readAddr1];
  assign readData2 = regs[readAddr2];

endmodule

/*
module memory (input clk, input [15:0] Addr, input [15:0] dataIn, input RW, input MIOEN, output Ready, output [15:0] memoryOutput, input load, input [1048575:0] contents);
	reg [1048575:0] mem;
	wire [19:0] newAddressEnd;
	wire [19:0] newAddressStart;
	assign newAddressEnd[19:4] = Addr;
	assign newAddressEnd[3:0] = 4'b0000;
	assign newAddressStart[19:4] = Addr;
	assign newAddressStart[3:0] = 4'b1111;
	always @(posedge clk) begin
		if (load) begin
			mem<= contents;
		end
		else if (MIOEN) begin
			if(RW) begin
				mem[newAddressStart:newAddressEnd] <= dataIn;
				Ready <=1;
				memoryOutput <= 0;
			end
			else begin
				memoryOutput <= mem[newAddressStart:newAddressEnd];
				Ready <=1;
			end
		end
		else begin
			Ready <=0;
			memoryOutput <=0;
		end
	end
endmodule
    */
module memory (input clk, input [15:0] Addr, input [15:0] dataIn, input RW, input MIOEN, output Ready, output [15:0] memoryOutput);
	reg [15:0] mem [65535:0];	
	
	always @(posedge clk) begin
		/*if (load) begin
			mem<=contents;
			//Ready <= 1;
		end
		else */if (MIOEN) begin
			if(RW) begin
				mem[Addr] <= dataIn;
				//Ready <=1;
			end
		end
		/*else begin
			//Ready <=0;
			memoryOutput <=0;
			mem[Addr] <= mem[Addr];
		end*/
	end
	assign memoryOutput = MIOEN ? mem[Addr] : 16'b0000000000000000;
	assign Ready = MIOEN;
endmodule

module LC3Simulation(input clk, input reset, input [15:0] PEECEE, input LOADPC, input memload, input [1048575:0] contents);
	wire [15:0] SR1OUT, SR2OUT, SR2MUXOUTPUT, 
	ALURESULT, ADDR1MUXRESULT, MARMUXADDERRESULT, MARMUXRESULT, PCPLUSONE, memoryOutput;
	wire GateALU, GateMARMUX, GatePC, GateMDR, ADDR1MUX, MARMUX, LDPC, RW,
	LDIR, Negative, Zero, Positive, LDMDR, LDMAR, MIOEN, LDBEN, LDCC, memReady; 
	reg [15:0] PC, mainBus,  MAR, MDR,IR, ADDR2MUXRESULT, PCMUXRESULT;
	wire [2:0] DR, SR2, LDREG;
	reg[2:0] CC, SR1;
	wire [1:0] ALUK, ADDR2MUX, PCMUX, DRMUX, SR1MUX;
	reg [5:0] state = 6'b010010;
	reg BEN;
	RegisterFile REGFILE (.clk(clk), .writeData(mainBus), .writeAddr(DR), .writeEn(LDREG),
	.readAddr2(SR2), .readAddr1(SR1), .readData2(SR2OUT), .readData1(SR1OUT));
	
	memory memoryAttachment ( clk, MAR, MDR, RW, MIOEN, memReady, memoryOutput);
	
	assign SR2MUXOUTPUT = (IR[5]) ? {{11{IR[4]}} , IR[4:0]} : SR2OUT;
	
	
	ALU  regularALU (.control(ALUK), .A(SR1OUT) , .B(SR2MUXOUTPUT) , .out(ALURESULT));
	
	
	always @(*) begin
		case (ADDR2MUX)
			0: ADDR2MUXRESULT = 16'b0;
			1: ADDR2MUXRESULT = {{10{IR[5]}},IR[5:0]};
			2: ADDR2MUXRESULT = {{7{IR[8]}},IR[8:0]};
			3: ADDR2MUXRESULT = {{5{IR[10]}},IR[10:0]};
		endcase
		
		case (SR1MUX)
			1: SR1 = IR[8:6];
			2: SR1 = {1'b1,1'b1,1'b0};
			default: SR1 = IR[11:9];
		endcase


		case (DRMUX)
			1: SR1 = {1'b1,1'b1,1'b1};
			2: SR1 = {1'b1,1'b1,1'b0};
			default: SR1 = IR[11:9];
		endcase

		case(PCMUX)
			0:PCMUXRESULT = PCPLUSONE;
			1:PCMUXRESULT = MARMUXADDERRESULT;
			default: PCMUXRESULT = mainBus;
		endcase
	end
	assign GateMARMUX = ~state[5] & ~state[4] & state[1];
	assign LDBEN = state==0;
	assign LDPC = ~state[5] & state[4] & (state==2 | state==6 | state==5 | state==4 | state==14);
	assign LDIR = state[5] & state[1] & state[0];
	assign PCMUX[1] = ~(state== 18 || state == 30);
	assign PCMUX[0] = state==30;
	assign GatePC = ~state[5] & ~state[0] & ((~(state[4] ^ state[3]) & state[2] & ~state[1]) | state[4:1] == 9); /* Error in compute for next line, state[27]*/
	assign LDCC = ~state[5] & (state[4:0] == 1 || state[4:0] == 5 || state[4:0] == 9 || state[4:0] ==14 || state[27]);
	assign GateALU = ~state[5] & ~state[4] & state[0] & ~state[1] & ~(state[2] & state[3]);
	assign GateMDR = (~state[5] & state[4] & state[3] & state[1] & (state[0] | state[2])) | (state[5] & state[1]);
	assign RW = state[4:0] == 5'b10000;
	assign LDMAR = ~state[5] & ((~state[4] & ~state[3] & state[1] &~state[0]) | (~state[4] & state[3] & state[1] & state[0] & state[0]) | (state[4] & ~state[2] & state[1] & ~state[0]));
	assign MIOEN = ~state[1] & ((~state[5] & state[4] & state[3]) | (~state[5] & state[4] & ~state[2] & ~state[0]) | (state[5] & ~state[4] & ~state[3] & ~state[2] & state[0]));
	assign MARMUX = state[4] | ~state[3] | ~state[2] | ~state[1] | ~state[0];
	assign LDMAR = (~state[5] & state[4] & state[3] & ~state[1]) | state[4:0]==23 | state==33;
	assign ALUK[0] = state[2];
	assign ALUK[1] = state[4] | state[3];
	assign SR1MUX[0] = ~(state==23);
	assign SR1MUX[1] = 1'b0;
	assign LDREG = ~state[5] & ((~state[4] & ~state[3] & state[2] & ~state[1]) | (~state[4] & ~state[2] & ~state[1] & state[0]) | (state[4:0] == 14 | state[4:0] ==27 | state[4:0] ==28));
	assign DRMUX = ~(state[4] ^ state[3]) & state[2] & ~state[1] & ~state[0];
	assign ADDR1MUX = state[2] & ((~state[1] & ~state[0]) | (~state[4] & ~state[3]));
	assign ADDR2MUX[0] = (state[0] & ~state[1]) | (state[2] & ~state[3] & ~state[4]);
	assign ADDR2MUX[1] = ~state[2] | (~state[1] & state[0]) | (state[3] & state[1]) | (state[4] & state[1]);

	always @(posedge clk) begin
		if(reset) begin
			state <= 18;
			PC <= (LOADPC) ? PEECEE : 16'b0000000000000000;
			MDR <= 0;
			MAR <= 0;
			IR <=0;
			CC<= 0;
		end
		else begin
						
			if(LDCC) begin
				CC[2]<=Negative;
				CC[1]<=Zero;
				CC[0]<=Positive;
			end
			else
				CC<=CC;

			if(LDMAR)
				MAR<=mainBus;
			else
				MAR<=MAR;

			if(LDMDR)
				MDR<= (MIOEN) ? memoryOutput : mainBus;
			else
				MDR<=MDR;

			if(LDIR)
				IR<=mainBus;
			else
				IR<=IR;

			if(LDPC)
				PC <= PCMUXRESULT;
			else
				PC <= PC;

			case (state)
				0: state <= {1'b0,BEN,1'b0, BEN, BEN,1'b0};
				1: state <= 18;
				2: state <= 25;
				3: state<= 23;
				4: state <= {5'b01010, IR[11]};
				5: state <= 18;
				6: state <= 25;
				7: state <= 23;
				9: state <= 18;
				10: state <= 24;
				11: state <= 29;
				12: state <= 18;
				14: state <= 18;
				15: state <= 28;
				16: state <= {state[5:2], memReady, state[0]};
				18: state <= 33;
				20: state <= 18;
				21: state <= 18;
				22: state <= 18;
				23: state <= 16;
				24: state <= {state[5:2], memReady, state[0]};
				25: state <= {state[5:2], memReady, state[0]};
				26: state <= 25;
				27: state <= 18;
				28: state <= {state[5:2], memReady, state[0]};
				29: state <= {state[5:2], memReady, state[0]};
				30: state <= 18;
				31: state <= 23;
				32: state <= {2'b00, IR[15:12]};
				33: state <= {state[5:2], memReady, state[0]};
				35: state <= 32;
				default: state <= 63;
			endcase
		end
	end

	assign ADDR1MUXRESULT = (ADDR1MUX) ? SR1OUT: PC;
	
	Sixteenbitadder MARMUXADDER (ADDR1MUX, ADDR2MUX, 0, MARMUXADDERRESULT, 0);
	
	Sixteenbitadder PCPLUSONEADDER (PC, 16'b0, 1, PCPLUSONE, 0);

	assign MARMUXRESULT = (MARMUX) ? {{8{1'b0}},IR[7:0]} : MARMUXADDERRESULT;

	assign Negative = mainBus[15];
	assign Zero = ~(|mainBus);
	assign Positive = ~(Negative | Zero);
	
	always @(*) begin

		if(GateMARMUX)
			mainBus = MARMUXRESULT;
		else if (GatePC)
			mainBus = PC;
		else if (GateALU)
			mainBus = ALURESULT;
		else if (GateMDR)
			mainBus = MDR;
		else
			mainBus = 16'bZZZZZZZZZZZZZZZZ;

		if(LDBEN)
			BEN = (Negative & IR[11])|(Zero & IR[10])|(Positive & IR[9]);
		else
			BEN =0;
	end
endmodule
